// ReportViewModel.swift
import Foundation
import FirebaseDatabase
import FirebaseAuth

@MainActor
class ReportViewModel: ObservableObject {
    @Published var reports: [Report] = []
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?

    // For report submission form binding
    @Published var reportTitle: String = ""
    @Published var reportDescription: String = ""

    private var dbRef: DatabaseReference!
    private var reportsNodeRef: DatabaseReference! // Specific reference to "reports" node
    private var reportsHandle: DatabaseHandle?

    init() {
        // Ensure FirebaseApp.configure() has been called in your AppDelegate or App struct
        dbRef = Database.database().reference()
        reportsNodeRef = dbRef.child("reports") // Reference to the "reports" node
        fetchReports()
    }

    deinit {
        if let handle = reportsHandle {
            reportsNodeRef.removeObserver(withHandle: handle)
        }
        print("ReportViewModel deinitialized and RTDB listener removed.")
    }

    func clearInputFields() {
        reportTitle = ""
        reportDescription = ""
        errorMessage = nil
    }

    // MARK: - Create Report
    func createReport(currentUserId: String, currentUsername: String) async -> Bool {
        guard !reportTitle.isEmpty, !reportDescription.isEmpty else {
            errorMessage = "Title and description cannot be empty."
            return false
        }

        isLoading = true
        errorMessage = nil

        // Create a new Report object using the synthesized memberwise initializer.
        // reportId and timestamp will use their default values from the Report struct.
        let newReport = Report(
            // reportId: will use its default UUID().uuidString()
            userId: currentUserId,
            username: currentUsername.isEmpty ? "Anonymous" : currentUsername,
            title: self.reportTitle,
            description: self.reportDescription
            // timestamp: will use its default Date().timeIntervalSince1970 * 1000
        )

        do {
            // Encode the Report object to a dictionary [String: Any]
            let reportData = try JSONEncoder().encode(newReport)
            let reportJSON = try JSONSerialization.jsonObject(with: reportData, options: []) as? [String: Any]

            guard let finalReportJSON = reportJSON else {
                errorMessage = "Failed to prepare report data for saving."
                isLoading = false
                return false
            }
            
            // Use newReport.reportId (which was generated by its default value) as the key
            try await reportsNodeRef.child(newReport.reportId).setValue(finalReportJSON)
            
            print("ReportViewModel: Successfully created report \(newReport.reportId)")
            clearInputFields() // Clear fields on success
            isLoading = false
            return true // Indicate success
        } catch {
            print("ReportViewModel: Error creating report - \(error.localizedDescription)")
            errorMessage = "Failed to create report: \(error.localizedDescription)"
            isLoading = false
            return false // Indicate failure
        }
    }

    // MARK: - Fetch Reports
    func fetchReports() {
        isLoading = true
        errorMessage = nil
        
        // Remove existing observer before adding a new one to prevent duplicates
        if let handle = reportsHandle {
            reportsNodeRef.removeObserver(withHandle: handle)
        }

        // Observe the "reports" node, order by timestamp for fetching
        reportsHandle = reportsNodeRef.queryOrdered(byChild: "timestamp").observe(.value) { [weak self] snapshot in
            guard let self = self else { return }
            
            guard snapshot.exists(), let value = snapshot.value as? [String: Any] else {
                print("ReportViewModel: No reports found or data is not in expected format.")
                self.reports = [] // Clear existing reports
                self.isLoading = false
                // Set error message only if snapshot exists but data is malformed
                self.errorMessage = snapshot.exists() ? "Could not parse report data." : nil
                return
            }

            var fetchedReports: [Report] = []
            for (key, reportData) in value { // key is the reportId (e.g., the UUID string)
                if let dict = reportData as? [String: Any] {
                    do {
                        // Convert dictionary back to Data, then decode
                        let jsonData = try JSONSerialization.data(withJSONObject: dict, options: [])
                        let decodedReport = try JSONDecoder().decode(Report.self, from: jsonData)
                        
                        // The decodedReport.reportId should match `key` because we store it.
                        // If there was a mismatch, it would indicate an issue.
                        // For example: if decodedReport.reportId != key { print("Warning: ID mismatch...") }

                        fetchedReports.append(decodedReport)
                    } catch {
                        print("ReportViewModel: Failed to decode report with key \(key): \(error)")
                        // Optionally, you could add this error to a list of partial errors
                    }
                } else {
                    print("ReportViewModel: Report data for key \(key) is not a dictionary.")
                }
            }
            
            // Sort by timestamp descending (newest first) client-side
            self.reports = fetchedReports.sorted(by: { $0.timestamp > $1.timestamp })
            
            print("ReportViewModel: Successfully fetched/updated \(self.reports.count) reports.")
            self.isLoading = false
            self.errorMessage = nil // Clear error on successful fetch
        } withCancel: { [weak self] error in
            guard let self = self else { return }
            print("ReportViewModel: Error fetching reports from RTDB - \(error.localizedDescription)")
            self.errorMessage = "Failed to fetch reports: \(error.localizedDescription)"
            self.reports = [] // Clear reports on error
            self.isLoading = false
        }
    }

    // MARK: - Delete Report
    func deleteReport(report: Report) async {
        guard let currentAuthUser = Auth.auth().currentUser else {
            errorMessage = "You must be logged in to delete a report."
            return
        }
        // Ensure the report has a userId and it matches the current user
        guard !report.userId.isEmpty, report.userId == currentAuthUser.uid else {
            errorMessage = "You can only delete your own reports."
            // This should also be enforced by Firebase security rules.
            return
        }

        isLoading = true
        errorMessage = nil
        
        // Use report.reportId to reference the child node
        let reportToDeleteRef = reportsNodeRef.child(report.reportId)

        do {
            try await reportToDeleteRef.removeValue()
            print("ReportViewModel: Successfully deleted report node \(report.reportId) from RTDB")
            // The .value observer will automatically update the local `reports` array.
            // If not using a live listener, you'd manually remove it:
            // self.reports.removeAll { $0.reportId == report.reportId }
        } catch {
            print("ReportViewModel: Error deleting report \(report.reportId) - \(error.localizedDescription)")
            errorMessage = "Failed to delete report: \(error.localizedDescription)"
        }
        isLoading = false
    }
}
